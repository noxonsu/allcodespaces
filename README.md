
# TeleWin
- это проект для управления и публикации кампаний в группах Telegram
- бэкэнд построен на Python Django
- каналы поддерживают мягкое удаление через флаг is_deleted (скрыты из списков и расчётов, восстанавливаются при повторной установке бота)
- кампании теперь имеют статусы draft/active/paused (создаются в draft)
- **безопасное удаление кампаний:**
  - кампании с публикациями (published posts) нельзя удалить - система блокирует операцию с понятной ошибкой
  - альтернатива удалению - архивирование через флаг `is_archived`
  - архивные кампании скрыты из списков по умолчанию, но доступны через фильтр
  - восстановление из архива возможно в любой момент через action "Разархивировать"
- при выходе кампании из draft уведомления о подтверждении каналов отправляются только один раз по неподтверждённым каналам
- юридические лица управляются через модель LegalEntity с полными реквизитами и валидациями, в карточке админки показываются связные каналы и агрегированные балансы
- каналы могут быть привязаны к юридическим лицам через поле legal_entity (опционально, с фильтрацией в админке)
- финансовые операции по каналам хранятся в модели ChannelTransaction в формате **Event Sourcing** (append-only ledger)
  - типы операций: income (начисление), refund (возврат), unfreeze (разморозка), freeze (заморозка), payout (выплата), commission (комиссия), adjustment (корректировка)
  - транзакции нельзя изменять или удалять - только добавлять (append-only)
  - для исправлений используются компенсирующие транзакции
- баланс канала отображается в админке и API (поля balance, frozen, available)
- выплаты по юрлицу — модель Payout со статусами draft/pending/paid/canceled, валидация суммы против доступного агрегированного баланса, периодом (с/по) и комментарием; при статусе paid баланс юрлица уменьшается (создаются payout-транзакции по каналам)
- расчёт баланса каналов выполняется сервисом BalanceService через простое суммирование всех транзакций (Event Sourcing подход)
  - баланс = SUM(amount) всех транзакций
  - заморожено = ABS(SUM(amount WHERE type='freeze'))
  - доступно = баланс - заморожено (но не может быть отрицательным)
  - нет race conditions благодаря append-only архитектуре
  - Redis кэширование для оптимизации запросов
- **интеграция с микросервисом парсинга** (двусторонняя):
  - **Исходящие webhook уведомления** при изменениях каналов (опционально)
    - автоматическая отправка событий при добавлении/удалении/восстановлении каналов
    - retry механизм с exponential backoff (3 попытки)
    - аутентификация через Bearer token
  - **Входящие запросы на публикацию** от микросервиса через защищённый API
    - эндпоинт `/api/publication-request/request-publication/` принимает запросы с каналом и форматом
    - автоматический выбор подходящего креатива по параметрам
    - создание публикации и отправка в бот
    - логирование всех запросов в модель PublicationRequest
    - возврат статусов: success/no_creative/error
- в карточке канала можно выбрать поддерживаемые форматы, настроить сетку таймслотов для «Фикс-слота», включить автоутверждение публикаций и указать минимальный интервал для «Автопилота» (все поля доступны и через `/api/channel/`, включая `publication_slots`)
- при добавлении канала в кампанию выполняются проверки пересечения форматов/таймслотов и ограничений «Автопилота»; при конфликте отправляются понятные ошибки с подсказками по свободным окнам
- архивирование кампаний: админка блокирует прямое удаление кампаний с публикациями и предлагает действие «Архивировать». Архивные кампании скрываются из списков по умолчанию и не участвуют в API/бот-интеграциях (эндпоинт `/api/campaign-channel/` фильтрует их автоматически)


## Стэк 
- Python (Django/DRF)
- python-telegram-bot
- Starlette
- PydanticV2
- Postgresql
- Redis
- Celery
- Nginx
- Jquery/bootstrap/html5

## мониторинг
- Grafana
- Promethus
- Grafana/loki
- Grafana/promtail

## Docker
- Docker файлы находятся в папке web_app
  - файл docker-compose.yml для Dev
  - файл docker-compose.stag.yml для прод
  

## Dev
запустить приложение для разработки довольно просто
- основной дев‑домен: https://telewin.wpmix.net (стейджовая копия фронтенда/админки)
- тестовый Telegram-бот для авторизации и проверки сценариев — @nashbudjetbot (см. `web_app/.env`)
- в корневой папке проекта где находится файл Makefile
    - запустить в терминале ```make up-b ```  для запуска проекта и создать containers
    - запустить в терминале ``` make up ``` для запуска проекта
- при первом запуске (или после обновлений статики) убедитесь, что выполнен `python3 manage.py collectstatic --no-input` — в docker-compose это теперь делается автоматически перед стартом приложения и складывает файлы в `web_app/staticfiles` (раздается через общий volume `static`)
- кампании и креативы поддерживают форматы «Спонсорство», «Фикс-слот» и «Автопилот»; для фикс-слота указывайте дату и время публикации
- предпросмотр креативов: в админке на форме креатива появилась кнопка «Отправить предпросмотр», она создаёт deeplink `/start` на бота через API `/api/message/<id>/preview/`; бот забирает данные по токену через `/api/message/preview/resolve/` (токен одноразовый)

### Архивирование кампаний

1. Нельзя удалить кампанию, если в ней есть опубликованные посты — админка покажет ошибку и предложит использовать действие «Архивировать».
2. Действие «Архивировать» доступно в списке кампаний, также в карточке архивной кампании выводится подсказка о том, что добавление каналов заблокировано.
3. Архивные кампании исключены из списков по умолчанию (фильтр `Архивирована = Нет`) и не попадают в API `/api/campaign-channel/` и пользовательские интеграции (бот не получит уведомления по архиву).
4. Для возврата кампании в работу используйте действие «Разархивировать» — записи вновь появятся в списках и попадут в API.

### Доступы для тестирования

**Админ-панель:** https://telewin.wpmix.net/admin/

**Учётные данные администратора:**
- Логин: `AlexeyFrolov`
- Пароль: `1234Fgtn@`

**Вход под другими пользователями:**
- Зайдите в админку под администратором
- Перейдите в раздел "Пользователи" → выберите нужного пользователя
- Нажмите кнопку "Войти под этим пользователем" (если требуется тестирование от лица конкретного юзера)

**Тест-кейсы:** см. [TESTING.md](TESTING.md)

### Миграции базы данных
- При появлении ошибок типа "column does not exist" система автоматически покажет красивую страницу с инструкцией
- Для запуска миграций в Docker: `docker-compose -f web_app/docker-compose.yml exec web-app python manage.py migrate`
- Для создания новых миграций: `python3 manage.py makemigrations` → `python3 manage.py migrate`
- Middleware `DatabaseMigrationCheckMiddleware` перехватывает ошибки БД и показывает понятное сообщение вместо DEBUG-страницы Django

## Как писать инструкции для ручного тестера
- Тестер не технарь: используйте простые шаги без команд и без терминала.
- Давайте ссылки на стейдж-домен `https://telewin.wpmix.net` и указывайте логины/роли, если нужны.
- Шаги делайте пронумерованными: куда зайти, что включить/выключить, что должно получиться.
- Избегайте внутренней терминологии разработки; пишите формулировки типа «откройте страницу…», «выберите чекбокс…», «убедитесь, что элемент не показывается».


## Production/Stag

для запуска проекта на прод

- в корневой папке проекта где находится файл Makefile
    - запустить в терминале ``` make up-b-stag ``` для запуска проекта и создать containers

планировалось добавить CI/CD.

## Генерация медиапланов
- Endpoint `POST /api/campaign/generate-media-plan/` принимает `campaign_ids` (UUID) и возвращает ссылку на Excel-файл + историю последних запросов. Авторизация — staff пользователь.
- Excel формируется по шаблону `web_app/core/media_plan/template.py` через `MediaPlanGenerator` (openpyxl). Файлы складываются в `MEDIA_ROOT/media_plans/`.
- Все генерации логируются в модели `MediaPlanGeneration`; посмотреть их можно в админке («Генерации медиапланов») вместе с ошибками и метаданными (ID кампаний, агрегаты).
- API сразу отдаёт `history` по текущему пользователю и `missing_campaign_ids`, если часть кампаний архивирована/не найдена.

## Auto-Testing Setup

Проект оснащен автоматизированными smoke-тестами на Puppeteer для проверки доступности основных экранов.

### Запуск тестов

```bash
# Установка зависимостей (первый раз)
npm install

# Запуск всех тестов
npm run test:all

# Только админские экраны
npm run test:admin

# Только пользовательские экраны
npm run test:user
```

### Что проверяется

**Admin Smoke Test (12 экранов):**
- Главная админки, списки каналов, кампаний, креативов
- Статистика, пользователи, владельцы каналов
- Юридические лица, финансовые операции, выплаты, токены

**User Smoke Test (4 экрана):**
- Главная страница, логин, API документация (Swagger/Redoc)

### Результаты

- Скриншоты всех страниц сохраняются в `screenshots/`
- JSON-отчеты: `screenshots/admin-test-report.json`, `screenshots/user-test-report.json`
- Exit code: 0 = успех, 1 = есть ошибки

Подробнее: [tests/README.md](tests/README.md)

## Contributing (важно)
- Всегда начинай с прочтения README (этого файла) в корне проекта.
- Работаем через docker-compose (см. `web_app/docker-compose.yml`); локальные команды прогоняем внутри контейнеров (`docker compose … exec web-app …`). Логи с `timeout`.
- Отчёт и инструкции для тестера публикуем напрямую в issue после коммита/пуша, подписываемся как claude.
- В отчёте в issue всегда добавляйте краткий план ручной проверки для тестера (ссылки на стенд + шаги).
- В коммитах обязательно указываем ID задачи/issue в сообщении (например, `feature/preview-token-api #51`), а в отчётах ссылаемся на коммит или issue.
- При просмотре комментариев в issue всегда скачивайте приложенные изображения (через `gh api <url> > /tmp/image` и открывайте файл) и проверяйте их содержимое.

### Работа с GitHub Issues и лейблами

**Лейблы для управления процессом:**

- `work in progress` - ставим когда начинаем работу над issue
- `QA` - ставим когда работа завершена и требуется проверка тестером

**Процесс работы с issue:**

1. **Начало работы:** всегда ставим `work in progress` и не снимаем его вручную (пусть остаётся как маркер выполняемой задачи).
   ```bash
   gh issue edit <номер> --add-label "work in progress"
   ```

2. **Готово к проверке:** добавляем `QA`, при этом `work in progress` не убираем.
   ```bash
   gh issue edit <номер> --add-label "QA"
   ```

3. **После тестирования:** тестер снимает `QA`/закрывает issue.

**Пример:**
```bash
# Начинаем работу над issue #55
gh issue edit 55 --add-label "work in progress"

# Отправили на QA (лейбл WIP остаётся)
gh issue edit 55 --add-label "QA"
```

### Определение приоритета задач

**Порядок приоритизации:**

1. **Наивысший приоритет:** Issue с лейблом `work in progress` БЕЗ лейбла `QA`
   - Ищем комментарий от QA с отчетом о тестировании
   - Это обычно самая важная задача, требующая исправлений после проверки

2. **Обычный приоритет:** Issues в порядке возрастания номеров (начиная с самого маленького)
   - **Пропускать** issues с лейблами:
     - `on hold` - отложенные задачи
     - `ready for review` - ожидают ревью, не требуют работы

**Пример поиска приоритетных задач:**
```bash
# Найти issues с работой после QA (высокий приоритет)
gh issue list --label "work in progress" --json number,labels,title

# Найти все активные issues (без on hold и ready for review)
gh issue list --json number,labels,title --jq '.[] | select((.labels | map(.name) | contains(["on hold", "ready for review"]) | not))'
```
